<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebModelDelivery — ONNX Harness</title>
  <!-- ═══════════════════════════════════════════════════════════════════════════
       CONFIGURATION — All external URLs in one place.
       To switch between CDN and local hosting, swap the URLs below.
       ═══════════════════════════════════════════════════════════════════════════ -->
  <script>
    // ── Library dependencies ──────────────────────────────────────────────────
    // To host locally: download the files, serve from localhost, swap URLs here.
    //   e.g.  transformersJs: './transformers.js'
    const DEPS = {
      transformersJs: 'https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.8.1',
    };

    // ── Model flat-repo sources ───────────────────────────────────────────────
    // Each URL points to a directory containing filemap.json + flat shard files.
    // The Service Worker intercepts /models/{name}/* requests from Transformers.js,
    // looks up the virtual path in filemap.json, fetches the real file(s) from
    // cdnBase, wraps them in a same-origin Response (COEP-safe), and returns them.
    //
    // To use locally hosted models instead of CDN, point to your local server:
    //   embedding: `${location.origin}/pkg-embedding`,
    //   reranker:  `${location.origin}/pkg-reranker`,
    const MODEL_SOURCES = {
      embedding: 'https://cdn.jsdelivr.net/gh/kulogix/wmd_onnx-community_embeddinggemma-300m-ONNX@v1.0.0',
      reranker:  'https://cdn.jsdelivr.net/gh/kulogix/wmd_mixedbread-ai_mxbai-rerank-xsmall-v1@v1.0.0',
    };
  </script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: { extend: { fontFamily: { mono: ['"JetBrains Mono"', 'Consolas', 'monospace'] } } }
    };
  </script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
  <style>
    [x-cloak] { display: none !important; }
    .log-scroll { scrollbar-width: thin; scrollbar-color: #475569 transparent; }
    .log-scroll::-webkit-scrollbar { width: 6px; }
    .log-scroll::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
    @keyframes pulse-bar { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }
    .bar-pulse { animation: pulse-bar 1.5s ease-in-out infinite; }
  </style>
</head>
<body class="bg-slate-950 text-slate-200 font-mono min-h-screen">

<div class="max-w-5xl mx-auto p-4 sm:p-6" x-data="harness()" x-init="init()" x-cloak>

  <!-- Header -->
  <div class="mb-6">
    <h1 class="text-xl font-semibold text-white flex items-center gap-2">
      <span class="text-emerald-400">&#9670;</span> WebModelDelivery — ONNX Harness
    </h1>
    <p class="text-xs text-slate-500 mt-1">
      Embedding + Reranker inference via Service Worker model delivery
      &middot; <span x-text="swStatus" class="text-slate-400"></span>
    </p>
  </div>

  <!-- ─── EMBEDDING CARD ─────────────────────────────────────────── -->
  <div class="bg-slate-900 border border-slate-800 rounded-lg p-4 mb-4">
    <div class="flex items-center justify-between flex-wrap gap-2 mb-3">
      <div class="flex items-center gap-2">
        <h2 class="text-sm font-semibold text-white">Embedding Model</h2>
        <span x-show="embReady" class="text-[10px] bg-emerald-900/60 text-emerald-400 px-2 py-0.5 rounded">LOADED</span>
      </div>
      <div class="flex items-center gap-2">
        <select x-model="embManifest" @change="sendInit()" class="text-xs bg-slate-800 border border-slate-700 rounded px-2 py-1 text-slate-300" :disabled="embLoading">
          <template x-for="opt in embManifestOpts" :key="opt.value">
            <option :value="opt.value" x-text="opt.label"></option>
          </template>
        </select>
        <button @click="loadEmbedding()" :disabled="embLoading" class="text-xs bg-blue-600 hover:bg-blue-500 disabled:opacity-40 text-white px-3 py-1 rounded">
          <span x-show="!embLoading">Load</span><span x-show="embLoading">Loading&hellip;</span>
        </button>
        <button x-show="embReady" @click="unloadEmbedding()" class="text-xs bg-slate-700 hover:bg-slate-600 text-white px-3 py-1 rounded">Unload</button>
      </div>
    </div>

    <!-- Progress -->
    <div x-show="embLoading || embReady" class="grid grid-cols-2 gap-3 mb-3">
      <div class="bg-slate-950 rounded p-2">
        <div class="text-[10px] text-slate-500 uppercase tracking-wide mb-1">Service Worker</div>
        <div class="h-1.5 bg-slate-800 rounded overflow-hidden">
          <div class="h-full bg-blue-500 rounded transition-all duration-300" :class="embLoading && !embSW.done ? 'bar-pulse' : ''"
               :style="`width:${embSW.percent}%`"></div>
        </div>
        <div class="text-[10px] text-slate-500 mt-1">
          <span x-text="embSW.percent+'%'"></span> &middot; <span x-text="fmtB(embSW.loaded)"></span>/<span x-text="fmtB(embSW.total)"></span>
          <span x-show="embSW.manifest" class="text-slate-600">&middot; <span x-text="embSW.manifest"></span></span>
        </div>
      </div>
      <div class="bg-slate-950 rounded p-2">
        <div class="text-[10px] text-slate-500 uppercase tracking-wide mb-1">Transformers.js</div>
        <div class="h-1.5 bg-slate-800 rounded overflow-hidden">
          <div class="h-full bg-emerald-500 rounded transition-all duration-300" :style="`width:${embRT.percent}%`"></div>
        </div>
        <div class="text-[10px] text-slate-500 mt-1"><span x-text="embRT.status"></span></div>
      </div>
    </div>

    <!-- Embedding inference -->
    <div x-show="embReady" class="border-t border-slate-800 pt-3">
      <div class="text-xs text-slate-400 mb-2">Cosine Similarity Demo</div>
      <div class="grid grid-cols-2 gap-2 mb-2">
        <textarea x-model="embTextA" class="text-xs bg-slate-800 border border-slate-700 rounded p-2 h-16 text-slate-300 resize-none" placeholder="Sentence A"></textarea>
        <textarea x-model="embTextB" class="text-xs bg-slate-800 border border-slate-700 rounded p-2 h-16 text-slate-300 resize-none" placeholder="Sentence B"></textarea>
      </div>
      <div class="flex items-center gap-3">
        <button @click="runEmbedding()" :disabled="embInferring" class="text-xs bg-emerald-700 hover:bg-emerald-600 disabled:opacity-40 text-white px-3 py-1 rounded">Compute</button>
        <span x-show="embResult !== null" class="text-xs">
          Similarity: <span class="text-white font-semibold" x-text="embResult?.toFixed(4)"></span>
          <span class="text-slate-500" x-text="embTime"></span>
        </span>
      </div>
    </div>
  </div>

  <!-- ─── RERANKER CARD ──────────────────────────────────────────── -->
  <div class="bg-slate-900 border border-slate-800 rounded-lg p-4 mb-4">
    <div class="flex items-center justify-between flex-wrap gap-2 mb-3">
      <div class="flex items-center gap-2">
        <h2 class="text-sm font-semibold text-white">Reranker Model</h2>
        <span x-show="rrReady" class="text-[10px] bg-emerald-900/60 text-emerald-400 px-2 py-0.5 rounded">LOADED</span>
      </div>
      <div class="flex items-center gap-2">
        <select x-model="rrManifest" @change="sendInit()" class="text-xs bg-slate-800 border border-slate-700 rounded px-2 py-1 text-slate-300" :disabled="rrLoading">
          <template x-for="opt in rrManifestOpts" :key="opt.value">
            <option :value="opt.value" x-text="opt.label"></option>
          </template>
        </select>
        <button @click="loadReranker()" :disabled="rrLoading" class="text-xs bg-blue-600 hover:bg-blue-500 disabled:opacity-40 text-white px-3 py-1 rounded">
          <span x-show="!rrLoading">Load</span><span x-show="rrLoading">Loading&hellip;</span>
        </button>
        <button x-show="rrReady" @click="unloadReranker()" class="text-xs bg-slate-700 hover:bg-slate-600 text-white px-3 py-1 rounded">Unload</button>
      </div>
    </div>

    <div x-show="rrLoading || rrReady" class="grid grid-cols-2 gap-3 mb-3">
      <div class="bg-slate-950 rounded p-2">
        <div class="text-[10px] text-slate-500 uppercase tracking-wide mb-1">Service Worker</div>
        <div class="h-1.5 bg-slate-800 rounded overflow-hidden">
          <div class="h-full bg-blue-500 rounded transition-all duration-300" :style="`width:${rrSW.percent}%`"></div></div>
        <div class="text-[10px] text-slate-500 mt-1"><span x-text="rrSW.percent+'%'"></span> &middot; <span x-text="fmtB(rrSW.loaded)"></span>/<span x-text="fmtB(rrSW.total)"></span></div>
      </div>
      <div class="bg-slate-950 rounded p-2">
        <div class="text-[10px] text-slate-500 uppercase tracking-wide mb-1">Transformers.js</div>
        <div class="h-1.5 bg-slate-800 rounded overflow-hidden">
          <div class="h-full bg-emerald-500 rounded transition-all duration-300" :style="`width:${rrRT.percent}%`"></div></div>
        <div class="text-[10px] text-slate-500 mt-1"><span x-text="rrRT.status"></span></div>
      </div>
    </div>

    <!-- Reranker inference -->
    <div x-show="rrReady" class="border-t border-slate-800 pt-3">
      <div class="text-xs text-slate-400 mb-2">Query&ndash;Document Ranking</div>
      <input x-model="rrQuery" class="text-xs bg-slate-800 border border-slate-700 rounded px-2 py-1.5 w-full mb-2 text-slate-300" placeholder="Query..." />
      <textarea x-model="rrDocs" class="text-xs bg-slate-800 border border-slate-700 rounded p-2 w-full h-24 text-slate-300 resize-none mb-2"
        placeholder="One document per line..."></textarea>
      <button @click="runReranker()" :disabled="rrInferring" class="text-xs bg-emerald-700 hover:bg-emerald-600 disabled:opacity-40 text-white px-3 py-1 rounded">Rank</button>
      <div x-show="rrResults.length" class="mt-2 space-y-1">
        <template x-for="(r, i) in rrResults" :key="i">
          <div class="flex items-center gap-2 text-xs">
            <span class="text-slate-500 w-5 text-right" x-text="'#'+(i+1)"></span>
            <span class="w-16 text-right font-semibold" :class="r.score > 0 ? 'text-emerald-400' : 'text-slate-500'" x-text="(r.score >= 0 ? '+' : '') + r.score.toFixed(3)"></span>
            <span class="text-slate-400 truncate" x-text="r.doc"></span>
          </div>
        </template>
        <div class="text-[10px] text-slate-600 mt-1" x-text="rrTime"></div>
      </div>
    </div>
  </div>

  <!-- ─── LOG ────────────────────────────────────────────────────── -->
  <div class="bg-slate-900 border border-slate-800 rounded-lg p-4">
    <div class="flex items-center justify-between mb-2">
      <h2 class="text-xs font-semibold text-slate-400 uppercase tracking-wide">Log</h2>
      <div class="flex gap-2">
        <button @click="clearCache()" class="text-[10px] bg-amber-800/60 hover:bg-amber-700/60 text-amber-300 px-2 py-0.5 rounded">Clear SW Cache</button>
        <button @click="log=[]" class="text-[10px] bg-slate-800 hover:bg-slate-700 text-slate-400 px-2 py-0.5 rounded">Clear Log</button>
      </div>
    </div>
    <div class="bg-slate-950 rounded p-2 max-h-64 overflow-y-auto log-scroll text-[11px] leading-relaxed space-y-0.5" x-ref="logBox">
      <template x-for="(entry, i) in log" :key="i">
        <div :class="{ 'text-slate-500': entry.t==='sys', 'text-blue-400': entry.t==='sw', 'text-emerald-400': entry.t==='rt', 'text-red-400': entry.t==='err' }">
          <span class="text-slate-700" x-text="entry.ts"></span> <span x-text="entry.m"></span>
        </div>
      </template>
      <div x-show="!log.length" class="text-slate-700 italic">Waiting for events...</div>
    </div>
  </div>

  <p class="text-[10px] text-slate-700 mt-3 text-center">
    Serve with <code class="text-slate-600">python3 cors_server.py</code> or <code class="text-slate-600">node serve.mjs</code>
    &middot; model-sw.js wraps cross-origin CDN responses for COEP compatibility
  </p>
</div>

<script>
// ── Load Transformers.js (URL from DEPS config above) ────────────────────────
//
// Transformers.js loads models by fetching files relative to the path you
// pass to from_pretrained(). We pass a URL-derived prefix (e.g. '/models/wmd_embeddinggemma_v1_a3f2/')
// — the Service Worker intercepts that, looks up filemap.json, and fetches the real
// file from the MODEL_SOURCES cdnBase (CDN or localhost, depending on your config).
//
// The model never needs to know whether it's CDN or local — the SW handles it.
//
// NOTE: This must NOT be type="module" — modules always defer and would run
// AFTER Alpine's defer script, causing "Can't find variable: harness" errors.
//
let AutoModel, AutoTokenizer, AutoModelForSequenceClassification;
const tfReady = (async () => {
  const TF = await import(DEPS.transformersJs);
  AutoModel = TF.AutoModel;
  AutoTokenizer = TF.AutoTokenizer;
  AutoModelForSequenceClassification = TF.AutoModelForSequenceClassification;
  TF.env.allowRemoteModels = false;   // don't fetch from HF Hub
  TF.env.allowLocalModels = true;     // use local paths (SW-intercepted)
  return TF;
})();

// ── URL-derived path prefixes ────────────────────────────────────────────────
// Generate stable, human-readable path prefixes from MODEL_SOURCES URLs.
// Same URL → same prefix → TF.js/SW cache hits on reload.
// Different URLs → different prefixes → no cache collisions.
function urlToPrefix(url) {
  const parts = url.replace(/\/+$/, '').split('/').filter(Boolean);
  let slug = parts[parts.length - 1] || 'model';
  slug = slug.replace(/@/g, '_').replace(/[^a-zA-Z0-9._-]/g, '_');
  let h = 0;
  for (let i = 0; i < url.length; i++) { h = ((h << 5) - h + url.charCodeAt(i)) | 0; }
  const hash = (h >>> 0).toString(36).slice(0, 4).padStart(4, '0');
  return `/models/${slug}_${hash}/`;
}

// Derive stable prefixes from configured MODEL_SOURCES
const MODEL_PREFIXES = {
  embedding: urlToPrefix(MODEL_SOURCES.embedding),
  reranker:  urlToPrefix(MODEL_SOURCES.reranker),
};

// ── Alpine component ────────────────────────────────────────────────────────
window.harness = () => ({
  swStatus: 'initializing…', log: [],
  // Embedding
  embManifest: '', embManifestOpts: [{value:'',label:'Loading…'}],
  embLoading: false, embReady: false, embInferring: false,
  embSW: {percent:0,loaded:0,total:0,done:false,manifest:null},
  embRT: {percent:0,status:'idle'},
  embTextA: 'The quick brown fox jumps over the lazy dog.',
  embTextB: 'A fast auburn fox leaps above a sleepy hound.',
  embResult: null, embTime: '',
  _em: null, _et: null,
  _embFilemap: null,
  // Reranker
  rrManifest: '', rrManifestOpts: [{value:'',label:'Loading…'}],
  rrLoading: false, rrReady: false, rrInferring: false,
  rrSW: {percent:0,loaded:0,total:0,done:false,manifest:null},
  rrRT: {percent:0,status:'idle'},
  rrQuery: 'How do neural networks learn?',
  rrDocs: 'Neural networks adjust weights through backpropagation during training.\nThe stock market experienced volatility this quarter.\nDeep learning uses gradient descent to minimize loss functions.\nPhotosynthesis converts sunlight into chemical energy in plants.\nTransformers use self-attention for sequence modeling.',
  rrResults: [], rrTime: '',
  _rm: null, _rt: null,
  _rrFilemap: null,

  // ── Init ─────────────────────────────────────────────────
  async init() {
    if (this._initDone) return;   // guard against Alpine re-firing
    this._initDone = true;
    this.L('sys', 'Loading Transformers.js...');
    try { await tfReady; } catch(e) { this.L('err', 'Transformers.js load failed: '+e.message); return; }
    this.L('sys', 'Transformers.js ready. Registering Service Worker...');

    if (!('serviceWorker' in navigator)) { this.L('err', 'Service Workers not supported'); return; }
    await navigator.serviceWorker.register('/model-sw.js', { scope: '/' });
    await navigator.serviceWorker.ready;
    if (!navigator.serviceWorker.controller) {
      this.L('sys', 'SW installed — reloading to activate...');
      location.reload(); return;
    }

    navigator.serviceWorker.addEventListener('message', (e) => {
      const d = e.data;
      if (d?.type === 'MODEL_SW_PROGRESS') {
        const target = d.pathPrefix === MODEL_PREFIXES.embedding ? 'embSW' : d.pathPrefix === MODEL_PREFIXES.reranker ? 'rrSW' : null;
        if (target) this[target] = { percent: d.percent, loaded: d.modelLoaded, total: d.modelTotal, done: d.done, manifest: d.manifest };
      }
      if (d?.type === 'MODEL_SW_CACHE_CLEARED') this.L('sys', 'SW cache cleared.');
    });

    // Fetch filemaps directly from MODEL_SOURCES to populate manifest dropdowns
    await Promise.all([this.fetchFM('embedding'), this.fetchFM('reranker')]);
    this.sendInit();
    this.swStatus = 'SW active';
    this.L('sys', 'Ready. Models: ' + (MODEL_SOURCES.embedding.includes('localhost') || MODEL_SOURCES.embedding.includes('127.0.0.1') ? 'local' : 'CDN'));
  },

  async fetchFM(which) {
    try {
      const r = await fetch(MODEL_SOURCES[which] + '/filemap.json');
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      const fm = await r.json();
      // Store filemap for later manifest.dtype lookup
      if (which === 'embedding') this._embFilemap = fm;
      else this._rrFilemap = fm;
      const names = Object.keys(fm.manifests || {});
      const opts = names.map(n => {
        const m = fm.manifests[n];
        const hint = m.onnx_stem ? m.onnx_stem : m.dtype ? m.dtype : '';
        const tag = hint ? ` [${hint}]` : '';
        return { value: n, label: `${n}${tag} (${this.fmtB(m.size)})` };
      });
      if (which === 'embedding') { this.embManifestOpts = opts.length ? opts : [{value:'',label:'none'}]; this.embManifest = names[0]||''; }
      else { this.rrManifestOpts = opts.length ? opts : [{value:'',label:'none'}]; this.rrManifest = names[0]||''; }
      this.L('sys', `${which}: ${names.join(', ')||'no manifests'}`);
    } catch(e) {
      if (which==='embedding') this.embManifestOpts=[{value:'',label:'Error'}];
      else this.rrManifestOpts=[{value:'',label:'Error'}];
      this.L('err', `${which} filemap: ${e.message}`);
    }
  },

  // ── SW config ────────────────────────────────────────────
  // Read ONNX loading options from filemap manifest metadata.
  // Packager stores onnx_stem (exact filename stem like "model_qint8_arm64")
  // which we pass to TF.js as model_file_name — no dtype guessing needed.
  // Falls back to dtype for legacy filemaps without onnx_stem.
  getModelOpts(fm, manifestName) {
    const m = fm?.manifests?.[manifestName];
    if (m?.onnx_stem) {
      // New-style: packager stored exact ONNX stem
      return { model_file_name: m.onnx_stem };
    }
    // Legacy fallback: infer dtype from manifest name
    const VALID = new Set(['fp32','fp16','q8','int8','uint8','q4','bnb4','q4f16']);
    if (!manifestName || manifestName === 'default') return { dtype: 'fp32' };
    if (VALID.has(manifestName)) return { dtype: manifestName };
    if (manifestName === 'quantized') return { dtype: 'q8' };
    return {};  // let TF.js decide
  },

  sendInit() {
    navigator.serviceWorker.controller?.postMessage({
      type: 'MODEL_SW_INIT',
      sources: [
        { pathPrefix: MODEL_PREFIXES.embedding, cdnBase: MODEL_SOURCES.embedding, progress: true, manifest: this.embManifest },
        { pathPrefix: MODEL_PREFIXES.reranker,  cdnBase: MODEL_SOURCES.reranker,  progress: true, manifest: this.rrManifest },
      ],
    });
  },

  // ── Load embedding ───────────────────────────────────────
  async loadEmbedding() {
    if (this.embReady) await this.unloadEmbedding();
    this.embLoading = true;
    this.embRT = {percent:0,status:'starting…'}; this.embSW = {percent:0,loaded:0,total:0,done:false,manifest:null};
    await tfReady;
    const t0 = performance.now();
    try {
      const cb = this.pCb('embRT','emb');
      // Transformers.js fetches from /models/embedding/* → SW intercepts → fetches from MODEL_SOURCES.embedding
      this._et = await AutoTokenizer.from_pretrained(MODEL_PREFIXES.embedding, { progress_callback: cb });
      this._em = await AutoModel.from_pretrained(MODEL_PREFIXES.embedding, { ...this.getModelOpts(this._embFilemap, this.embManifest), progress_callback: cb });
      const ms = (performance.now()-t0)|0;
      this.embReady = true; this.embRT = {percent:100,status:`ready ✓ ${ms}ms`};
      navigator.serviceWorker.controller?.postMessage({type:'MODEL_SW_COMPLETE',pathPrefix:MODEL_PREFIXES.embedding});
      this.L('sys', `Embedding loaded in ${ms}ms`);
    } catch(e) { this.embRT={percent:0,status:'error: '+e.message}; this.L('err','Embedding: '+e.message); }
    this.embLoading = false;
  },
  async unloadEmbedding() { this._em?.dispose?.(); this._em=null; this._et=null; this.embReady=false; this.embResult=null; this.L('sys','Embedding unloaded.'); },

  async runEmbedding() {
    if (!this._em||!this._et) return;
    this.embInferring = true;
    const t0 = performance.now();
    try {
      const eA = await this._em(await this._et(this.embTextA,{padding:true,truncation:true}));
      const eB = await this._em(await this._et(this.embTextB,{padding:true,truncation:true}));
      const a = eA.sentence_embedding?.data || eA.last_hidden_state?.data;
      const b = eB.sentence_embedding?.data || eB.last_hidden_state?.data;
      let dot=0,na=0,nb=0; for(let i=0;i<a.length;i++){dot+=a[i]*b[i];na+=a[i]*a[i];nb+=b[i]*b[i];}
      this.embResult = dot/(Math.sqrt(na)*Math.sqrt(nb));
      this.embTime = `(${(performance.now()-t0)|0}ms)`;
    } catch(e) { this.L('err','Embed inference: '+e.message); }
    this.embInferring = false;
  },

  // ── Load reranker ────────────────────────────────────────
  async loadReranker() {
    if (this.rrReady) await this.unloadReranker();
    this.rrLoading = true;
    this.rrRT = {percent:0,status:'starting…'}; this.rrSW = {percent:0,loaded:0,total:0,done:false,manifest:null};
    await tfReady;
    const t0 = performance.now();
    try {
      const cb = this.pCb('rrRT','rr');
      // Transformers.js fetches from /models/reranker/* → SW intercepts → fetches from MODEL_SOURCES.reranker
      this._rt = await AutoTokenizer.from_pretrained(MODEL_PREFIXES.reranker, { progress_callback: cb });
      this._rm = await AutoModelForSequenceClassification.from_pretrained(MODEL_PREFIXES.reranker, { ...this.getModelOpts(this._rrFilemap, this.rrManifest), progress_callback: cb });
      const ms = (performance.now()-t0)|0;
      this.rrReady = true; this.rrRT = {percent:100,status:`ready ✓ ${ms}ms`};
      navigator.serviceWorker.controller?.postMessage({type:'MODEL_SW_COMPLETE',pathPrefix:MODEL_PREFIXES.reranker});
      this.L('sys',`Reranker loaded in ${ms}ms`);
    } catch(e) { this.rrRT={percent:0,status:'error: '+e.message}; this.L('err','Reranker: '+e.message); }
    this.rrLoading = false;
  },
  async unloadReranker() { this._rm?.dispose?.(); this._rm=null; this._rt=null; this.rrReady=false; this.rrResults=[]; this.L('sys','Reranker unloaded.'); },

  async runReranker() {
    if (!this._rm||!this._rt) return;
    this.rrInferring = true;
    const docs = this.rrDocs.split('\n').map(s=>s.trim()).filter(Boolean);
    const t0 = performance.now();
    try {
      const results = [];
      for (const doc of docs) {
        const enc = await this._rt(this.rrQuery, {text_pair:doc, padding:true, truncation:true});
        const out = await this._rm(enc);
        results.push({doc, score: out.logits.data[0]});
      }
      results.sort((a,b) => b.score - a.score);
      this.rrResults = results;
      this.rrTime = `Ranked ${docs.length} docs in ${(performance.now()-t0)|0}ms`;
    } catch(e) { this.L('err','Reranker inference: '+e.message); }
    this.rrInferring = false;
  },

  // ── Helpers ──────────────────────────────────────────────
  pCb(rtKey, label) {
    return (info) => {
      const f = (info.file||'').split('/').pop();
      if (info.status==='progress') this[rtKey] = {percent:Math.round(info.progress||0), status:`${f} ${Math.round(info.progress||0)}%`};
      else if (info.status==='done') this[rtKey] = {...this[rtKey], status:`${f} ✓`};
      else if (info.status==='initiate'||info.status==='download') this.L('rt',`[${label}] ${info.status}: ${f}`);
      else if (info.status==='ready') this[rtKey] = {percent:100,status:'ready'};
    };
  },
  fmtB(b) { return !b?'0 B':b>=1048576?(b/1048576).toFixed(1)+' MB':b>=1024?(b/1024).toFixed(1)+' KB':b+' B'; },
  clearCache() {
    navigator.serviceWorker.controller?.postMessage({type:'MODEL_SW_CLEAR_CACHE'});
    caches.delete('transformers-cache').then(ok => { if(ok) this.L('sys','Cleared transformers-cache.'); }).catch(()=>{});
    this.L('sys','Clearing caches...');
  },
  L(t,m) {
    this.log.push({t,m,ts:new Date().toTimeString().slice(0,8)});
    if(this.log.length>300) this.log.splice(0,50);
    this.$nextTick(()=>{ const el=this.$refs.logBox; if(el) el.scrollTop=el.scrollHeight; });
  },
});
</script>
<script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3/dist/cdn.min.js"></script>
</body>
</html>
